# -*- coding: utf-8 -*-
"""farmchainx.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iRuxgqOfb0kTtWhraD4Iev7aM7WDb6rX
"""

#!unzip /content/farmchainxdataset.zip -d /content/farmchainxdataset

#pip install ultralytics opencv-python pillow pandas matplotlib seaborn tqdm

# pip install ultralytics opencv-python pillow pandas matplotlib seaborn tqdm

import os
import cv2
import numpy as np
import pandas as pd
from PIL import Image
from ultralytics import YOLO
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='darkgrid')
import warnings
warnings.filterwarnings('ignore')

# ====== PATH CONFIGURATION ======
# Update this path to where your data is located in Colab
BASE_DIR = r"/content/farmchainxdataset/farmchainxdataset/Fruit Quality Classification"
#DATA_DIR = os.path.join(BASE_DIR, "dataset")
DATA_DIR = BASE_DIR  # because train/ and valid/ are already inside BASE_DIR
TRAIN_IMG_DIR = os.path.join(DATA_DIR, "train", "images")
DATA_YAML = os.path.join(DATA_DIR, "data.yaml")
RUN_DIR = os.path.join(r"/content/runs", "detect", "train")

# ====== LOAD AND INSPECT IMAGE ======
sample_img_path = os.path.join(TRAIN_IMG_DIR, "20190809_122412_jpg.rf.14a7dc799d0eb13cb694d1fe08677651.jpg")
image = cv2.imread(sample_img_path)
h, w, c = image.shape
print(f"The image has dimensions {w}x{h} and {c} channels.")

# ====== LOAD BASE MODEL ======
model = YOLO("yolov8n.pt")

# ====== TEST PREDICTION ======
result_predict = model.predict(source=sample_img_path, imgsz=640)
plot = result_predict[0].plot()
plot = cv2.cvtColor(plot, cv2.COLOR_BGR2RGB)
Image.fromarray(plot).show()

# ====== TRAIN FINAL MODEL ======
Final_model = YOLO('yolov8n.yaml').load('yolov8n.pt')

Result_Final_model = Final_model.train(
    data=DATA_YAML,
    epochs=25,
    imgsz=640,
    batch=16,
    lr0=0.01,
    dropout=0.15,
    device=0
)

# ====== METRIC VISUALIZATION ======
list_of_metrics = ["P_curve.png", "R_curve.png", "confusion_matrix.png"]
for i in list_of_metrics:
    img_path = os.path.join(RUN_DIR, i)
    if os.path.exists(img_path):
        img = cv2.imread(img_path)
        plt.figure(figsize=(16, 12))
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.title(i)
        plt.show()

# ====== TRAINING METRICS ======
results_path = os.path.join(RUN_DIR, "results.csv")
results = pd.read_csv(results_path)
results.columns = results.columns.str.strip()

fig, axs = plt.subplots(nrows=5, ncols=2, figsize=(15, 15))
sns.lineplot(x='epoch', y='train/box_loss', data=results, ax=axs[0,0])
sns.lineplot(x='epoch', y='train/cls_loss', data=results, ax=axs[0,1])
sns.lineplot(x='epoch', y='train/dfl_loss', data=results, ax=axs[1,0])
sns.lineplot(x='epoch', y='metrics/precision(B)', data=results, ax=axs[1,1])
sns.lineplot(x='epoch', y='metrics/recall(B)', data=results, ax=axs[2,0])
sns.lineplot(x='epoch', y='metrics/mAP50(B)', data=results, ax=axs[2,1])
sns.lineplot(x='epoch', y='metrics/mAP50-95(B)', data=results, ax=axs[3,0])
sns.lineplot(x='epoch', y='val/box_loss', data=results, ax=axs[3,1])
sns.lineplot(x='epoch', y='val/cls_loss', data=results, ax=axs[4,0])
sns.lineplot(x='epoch', y='val/dfl_loss', data=results, ax=axs[4,1])

plt.suptitle('Training Metrics and Loss', fontsize=24)
plt.tight_layout()
plt.show()

# ====== EVALUATE MODEL ======
best_model_path = os.path.join(RUN_DIR, "weights", "best.pt")
Valid_model = YOLO(best_model_path)
metrics = Valid_model.val(split='val')

print("\nModel Evaluation:")
for k, v in metrics.results_dict.items():
    print(f"{k}: {v:.4f}")

# ====== TEST PREDICTIONS ======
images = os.listdir(TRAIN_IMG_DIR)
for i in range(5):
    image_path = os.path.join(TRAIN_IMG_DIR, images[i])
    result_predict = Valid_model.predict(source=image_path, imgsz=640, iou=0.4)
    plot = result_predict[0].plot()
    plot = cv2.cvtColor(plot, cv2.COLOR_BGR2RGB)
    Image.fromarray(plot).show()

# ====== TRAINING METRICS ======
results_path = os.path.join(RUN_DIR, "results.csv")
results = pd.read_csv(results_path)
results.columns = results.columns.str.strip()

fig, axs = plt.subplots(nrows=5, ncols=2, figsize=(15, 15))
sns.lineplot(x='epoch', y='train/box_loss', data=results, ax=axs[0,0])
sns.lineplot(x='epoch', y='train/cls_loss', data=axs[0,1])
sns.lineplot(x='epoch', y='train/dfl_loss', data=results, ax=axs[1,0])
sns.lineplot(x='epoch', y='metrics/precision(B)', data=results, ax=axs[1,1])
sns.lineplot(x='epoch', y='metrics/recall(B)', data=results, ax=axs[2,0])
sns.lineplot(x='epoch', y='metrics/mAP50(B)', data=results, ax=axs[2,1])
sns.lineplot(x='epoch', y='metrics/mAP50-95(B)', data=results, ax=axs[3,0])
sns.lineplot(x='epoch', y='val/box_loss', data=results, ax=axs[3,1])
sns.lineplot(x='epoch', y='val/cls_loss', data=results, ax=axs[4,0])
sns.lineplot(x='epoch', y='val/dfl_loss', data=results, ax=axs[4,1])

plt.suptitle('Training Metrics and Loss', fontsize=24)
plt.tight_layout()
plt.show()

# ====== EVALUATE MODEL ======
best_model_path = os.path.join(RUN_DIR, "weights", "best.pt")
Valid_model = YOLO(best_model_path)
metrics = Valid_model.val(split='val')

print("\nModel Evaluation:")
for k, v in metrics.results_dict.items():
    print(f"{k}: {v:.4f}")

# ====== TEST PREDICTIONS ======
images = os.listdir(TRAIN_IMG_DIR)
for i in range(5):
    image_path = os.path.join(TRAIN_IMG_DIR, images[i])
    result_predict = Valid_model.predict(source=image_path, imgsz=640, iou=0.4)
    plot = result_predict[0].plot()
    plot = cv2.cvtColor(plot, cv2.COLOR_BGR2RGB)
    Image.fromarray(plot).show()

import os

image_path = "/content/Fruit Quality Classification/train/images/20190809_122412_jpg.rf.14a7dc799d0eb13cb694d1fe08677651.jpg"
if os.path.exists(image_path):
    print(f"The file {image_path} exists.")
else:
    print(f"The file {image_path} does not exist.")